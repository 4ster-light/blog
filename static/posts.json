[
  {
    "slug": "learning-python",
    "title": "Python and Junior Developers",
    "description": "Why Python's simplicity and popularity can become a problem at times",
    "date": "2024-12-02",
    "tags": [
      "python",
      "job market",
      "programming"
    ],
    "content": "I wanted to talk about this ever since I started feeling confident enough to say “I KNOW Python” (a\nbit cocky of me since I have a lot to learn of course, but you understand the point). As everyone\nreading this probably knows, Python has an extremely simple syntax, the typical coding example you\nmay show to someone that has never coded before reads just as plain English language in most of it.\n\n## The Problem: Overconfidence vs Competence\n\nWhat I’ve found is that this provides some so called “Software Engineers” (as self proclaimed in\ntheir portfolios and resumes) with the illusion of possessing great programming skills and deserve a\njob straight away. Don't get me wrong, it is to celebrate that there is a language that empowers\nnewcomers so much, but still, as said in the title, there is a great difference between being\ncompetent up to some extent, and just being overconfident.\n\nWhat I'm trying to say is that, this is a problem I feel is not addressed often nor well enough, and\nit is similar to what I like to call “The React myriad” in web development, where you find a lot of\n“self taught developers” everywhere that pretend to be web devs, wielding their To-Do apps as mighty\nswords of engineering, without having basic HTML knowledge.\n\nAnd then you ask this “Python devs” to implement some coding example that is not really that\ncomplicated if we are being honest, like some iterator:\n\n```python\nclass PrimeGenerator:\n    def __init__(self):\n        self._sieve = {}  # Dictionary for sieve storage\n        self.current = 2  # Start checking from 2\n\n    def __iter__(self):\n        return self\n\n    def __next__(self) -> int:\n        while self.current in self._sieve:\n            # Move multiples to their next multiple\n            for prime in self._sieve[self.current]:\n                self._sieve\n                    .setdefault(prime + self.current, [])\n                    .append(prime)\n            del self._sieve[self.current]\n            self.current += 1\n        # Found a prime\n        self._sieve[self.current * 2] = [self.current]\n        prime = self.current\n        self.current += 1\n        return prime\n\n    def take(self, n: int) -> list[int]:\n        return [next(self) for _ in range(n)]\n```\n\nThey may not even know what to do, some of them having no clue or previous knowledge of the `yield`\nkeyword existing in Python, neither what `__iter__` or `__next__` are or why they should be used\nrather than creating a custom method yourself.\n\nAs you can see this is a pretty straight forward example that well explained should present no\nproblem to anyone that has been learning how to code for a while. The little quircks that show if\nyou actually know the language, the tool, you claim to know. Just 27 lines of python code are\ndemonstraiting key concepts like custom iterators, generator logic, and algorithmic efficiency,\nwhich to may of you are probably a no brainer, but of course that new people need to learn it at\nsome point, and not fall into **Dunning-Kruger** syndrome. As a result of this they may even dismiss\nmore complex features as unnecessary and not worth the time to learn, deepening even more the gap\nbetween surface level semantics and the actual richness of the language.\n\nThis makes me honestly sad since I love this language for being so versatile and adaptable for many\nuse cases, but still these people give it a bad name, making it a toy language or making it seem\nlike it has bad DX (which I understand that to a certain extent is a subjective quality to have)\nalthough it not being like this for a lot of people that use it daily.\n\n## YouTube tutorial syndrome\n\nA major contributor to this issue is what I like to call the \"YouTube Tutorial Syndrome.\" Online\ntutorials are fantastic starting points, but they tend to focus on **replication** rather than\n**understanding**. A developer may follow along with a video to create a simple application but\nstruggle to extend or modify it because they lack a firm grasp of the principles behind the code.\n\nThis over-reliance on tutorials can create a false sense of accomplishment. When faced with unique\nchallenges, these developers often freeze, unable to deviate from the patterns shown in tutorials.\n\n## Bridging the Gap: From Syntax to Engineering\n\nI know that in this list everything has been mentioned several times in the software community, but\nthey are not repeated/regarded enough apparently:\n\n- **Emphasize Computer Science Fundamentals:** Encourage learners to study data structures,\n  algorithms, and design patterns. These concepts are language-agnostic and form the backbone of\n  software engineering. Most people do not need to be experts of course, but basic knowledge always\n  comes in handy. And even if you end up disagreeing with some of this, because even experienced\n  engineers may come up with bad abstractions, you have learned **\"the why\"** of the problem, you\n  have a fundamented opinion, a perfectly valid one even if subjective.\n- **Promote Project-Based Learning:** Encourage developers to build complex, real-world projects\n  that go beyond simple scripts or To-Do apps. This advice is very cliche, but it is the only way to\n  truly understand software architecture and system design, which is something most tend to not pay\n  enough attention about and when they find themselves in a situation where they need to make a\n  decision, they tend to go with the simplest solution, which is not always the best one.\n- **Foster a culture of Continuous Learning:** The tech industry evolves rapidly. Instill the\n  importance of staying updated with new technologies, best practices, and industry trends.\n- **Encourage Code Reviews and Collaboration:** Participate in open-source projects or peer code\n  reviews. This exposure to different coding styles and problem-solving approaches is crucial for\n  growth. We benefit from other developers' experience and knowledge, as we've said before, even if\n  we don't agree, a bad lesson is sometimes a better lesson.\n\nBy implementing these strategies, we can help bridge the gap between knowing Python syntax and\nbecoming a proficient software engineer, ensuring that Python's simplicity becomes a stepping stone\nrather than a stumbling block in a developer's journey.\n\n### Bonus: The obscurity of Decorators\n\nThis is a very interesting topic, and I'm not going to go into too much detail here, but I think\nit's worth mentioning. Even by really talented and experienced developers this is something that\ntends to produce resentment and criticism, because decorators modify the behavior of a function,\nwhich is some argue could make the code harder to trace and debug.\n\nThere are very idiomatic and simple ways of using them, which, being a Rust developer myself and\nthese being very similar to procedural macros at a higher level, I think it's safe to say that they\nare not that obscure and are a pretty powerful tool. Many frameworks even relying on them heavily to\nenhance the DX of their code.\n\nAnd can even be used personally to make your life easier without much effort, like:\n\n```python\nimport time\n\ndef benchmark(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Benchmark executed in {end_time-start_time:.6f} seconds.\")\n        return result\n    return wrapper\n\n@benchmark\ndef slow_function():\n    for _ in range(10**6):\n        pass\n\nslow_function()\n```\n\nThis is a very simple example, but it shows how you can use decorators to add functionality to a\nfunction without modifying its code, which is something that is very common in Python and can be\ndone in Rust and many popular languages where it is used **heavily**.\n\n## Conclusion\n\nI hope this post has been useful and has given you some insight into the complexity of Python and\nthe challenges that developers face when learning it. I'm sure you've learned a lot about the\nlanguage and how it can be used to solve problems, but I also hope that you've gained some\nperspective on the challenges that developers face when learning a new language.\n\nIf you find any issue with this posts content or the way I express myself, please let me know ;),\nI'm always open to feedback and suggestions as a very unexperienced writer myself at the moment I'm\nwriting this.\n"
  },
  {
    "slug": "hello-world",
    "title": "Hello World!",
    "description": "Whoami, my journey to the world of programming",
    "date": "2024-12-01",
    "tags": [
      "personal",
      "journey"
    ],
    "content": "## Hi\n\nIf you are reading this you probably already know who I am, a teenage software developer from Spain,\nmy name is David, but most know me as Aster :).\n\n### The spark\n\nLet's take this from the beginning, so you know where I'm coming from. I began to be, at least,\ncurious about coding when I was just a kid (at the moment I'm writing this I'm 17 years old),\nbecause my father decided to study his second university degree, Computer Science, and was handed an\nassignment to make `Space Invaders` in Java, and tested the game he made with me.\n\n### First try\n\nAfter, that several years passed, until I was already in my first year of high school at 12 years\nold, when for some reason I can't even remember I wanted to give this craft a try. Of course as you\nmay imagine by that previous experience, I asked if he could teach me since I didn't know where\nshould I start or what to do jajaja. He opened his Eclipse IDE in Windows 7 Pro and there I went, I\nonly lasted two weeks of course, I was a kid trying to understand what a function was in a language\nwhere _\"Hello World\"_ spans dozens of characters, but anyway let's take another leap forward.\n\n### Ok, now this time for real\n\nNow you find me at 15 years old, that being two years ago at the moment (December 2024 right now)\nmight feel like yesterday to most but I'm a teen, that's like 11% of my life (which if you think\nabout it is a lot). I started playing with Python as everyone that starts coding after 2010 usually\ndoes, had my VSCode running on the Windows 10 without activation key, and was simply ready to go,\nThis time I took two months before I was bored of `Flask` and `Jinja`, but without that I don't\nthink I would be writing this today to tell you jejeje.\n\nThis is one of the reasons why Python holds a special place in my heart, as I'd think it does for\nmost the first language they ever learnt and actually enjoyed, or even if you didn't really enjoy\nyou'll get those memories and get that feeling \"how far I've come haven't I?\".\n\n### Hell yeah, now we are talking\n\nAnd now the big moment, what we were all waiting for, July 2024, I just turned 17 years old, I came\nacross some of my old toy websites in that directory you forget about in your old pendrive, and I\nwas like, \"damn, maybe I should try this\", because I'm that kind of person that (used) to waste\ntheir summer without actually doing anything productive. I went all in, I was extremely motivated,\nwatched some YouTube tutorials, and created my now, if I dare say it, quite decent sized Twitter\naccount [@4ster_light](https://x.com/4ster_light), where I share everything about my projects and\nlearning by the way. As much as I sometimes get frustrated with that app, it's the core of my\njourney as a developer and I owe so much to it, it and all the people there that support me keep me\ndoing what I do and I love it more each day.\n\nA quick summary is that I love programming languages and the web, I like to try languages as a\nhobby, getting to know them and expanding my knowledge about any programming style or paradigm that\nexists and can improve my current skills, this opinion is always changing but I'm going to leave it\nhere so you or me can come back look at it and laugh for a moment: The languages I enjoy to write\nthe most and the ones I currently see myself using in the future are: Python, Rust, OCaml, Go, Lua,\nHaskell, and RACKET (which by the way explains the little λ on my socials), all for different\nreasons, the most interesting ones right now for me being Racket, Ocaml and Rust.\n\nProbably my GitHub gives a better view of my stuff either now or whenever you are reading this so,\nhave a look and enjoy! [(Click here)](https://github.com/4ster-light)\n\n## See you around :)\n\nSo, yeah, that's pretty much my story and who I am, I may have changed in the future, as I've\nmentioned several times I'm writing this at 17 years old. My writing skills nor storytelling\ncapabilities may not be the best, but I'm sure I'll get better jajaja, I hope you enjoy all of my\ncontents and/or apps, so, as\n"
  }
]
